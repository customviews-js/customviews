
/**
 * Descriptor for an anchor that represents a DOM element.
 */
interface AnchorDescriptor {
    tag: string;          // e.g., "P", "BLOCKQUOTE"
    index: number;        // e.g., 2 (It is the 2nd <p> in the container)
    parentId?: string;    // ID of the nearest parent that HAS a hard ID (e.g., #section-configuration)
    textSnippet: string;  // First 32 chars of text content (normalized)
    textHash: number;     // A simple hash of the full text content
}

/**
 * Engine for generating and resolving robust anchors.
 * 
 * It implements a simple anchor generation and resolution algorithm that uses a combination of 
 * structural, contextual, and content-based hints to generate a unique anchor for a given DOM element.
 * 
 * The anchor is generated by first creating an AnchorDescriptor for the element, which contains 
 * information about the element's tag, index, parent ID, and text content. This descriptor is then 
 * serialized into a URL-safe string using a minification algorithm.
 * 
 * The anchor is then resolved by searching for the element in the DOM using the serialized string.
 *  
 */
export class AnchorEngine {

    /**
     * Generates a simple hash code for a string.
     * 
     * It takes each character's Unicode code point and uses it to update the hash value.
     */
    private static hashCode(str: string): number {
        let hash = 0;
        if (str.length === 0) return hash;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32bit integer
        }
        return hash;
    }

    /**
     * Normalizes text content by removing excessive whitespace.
     * 
     * It trims leading and trailing whitespace and replaces multiple spaces with a single space.
     */
    private static normalizeText(text: string): string {
        return text.trim().replace(/\s+/g, ' ');
    }

    /**
     * Creates an AnchorDescriptor for a given DOM element.
     */
    static createDescriptor(el: HTMLElement): AnchorDescriptor {
        const tag = el.tagName;
        const textContent = el.textContent || "";
        const normalizedText = this.normalizeText(textContent);

        // Find nearest parent with an ID
        let parentId: string | undefined;
        let parent = el.parentElement;
        while (parent) {
            if (parent.id) {
                parentId = parent.id;
                break;
            }
            parent = parent.parentElement;
        }

        // Calculate index relative to the container (either the found parent or document.body)
        const container = parent || document.body;
        const siblings = Array.from(container.querySelectorAll(tag));
        // Index is the position of the element in the list of siblings, where siblings are those of the same tag.
        const index = siblings.indexOf(el);

        const descriptor: AnchorDescriptor = {
            tag,
            index: index !== -1 ? index : 0,
            textSnippet: normalizedText.substring(0, 32),
            textHash: this.hashCode(normalizedText)
        };

        if (parentId) {
            descriptor.parentId = parentId;
        }

        return descriptor;
    }

    /**
     * Serializes a list of AnchorDescriptors into a URL-safe string.
     */
    static serialize(descriptors: AnchorDescriptor[]): string {
        // Minify keys for compactness
        const minified = descriptors.map(d => ({
            t: d.tag,
            i: d.index,
            p: d.parentId,
            s: d.textSnippet,
            h: d.textHash
        }));
        const json = JSON.stringify(minified);
        // Base64 encode
        return btoa(encodeURIComponent(json));
    }

    /**
     * Deserializes a URL-safe string back into a list of AnchorDescriptors.
     */
    static deserialize(encoded: string): AnchorDescriptor[] {
        try {
            const json = decodeURIComponent(atob(encoded));
            const minified = JSON.parse(json);
            return minified.map((m: any) => ({
                tag: m.t,
                index: m.i,
                parentId: m.p,
                textSnippet: m.s,
                textHash: m.h
            }));
        } catch (e) {
            console.error("Failed to deserialize anchor:", e);
            return [];
        }
    }

    /**
     * Finds the best DOM element match for a descriptor.
     */
    static resolve(root: HTMLElement, descriptor: AnchorDescriptor): HTMLElement | null {
        // 1. Scope
        let scope: HTMLElement = root;
        if (descriptor.parentId) {
            const foundParent = root.querySelector(`#${descriptor.parentId}`);
            if (foundParent instanceof HTMLElement) {
                scope = foundParent;
            } else {
                // Fallback: if parent ID not found, search global root - document.body
                const globalParent = document.getElementById(descriptor.parentId);
                if (globalParent) {
                    scope = globalParent;
                }
            }
        }

        // 2. Candidate Search
        const candidates = Array.from(scope.querySelectorAll(descriptor.tag)) as HTMLElement[];

        // 3. Scoring
        let bestMatch: HTMLElement | null = null;
        let highestScore = 0;

        candidates.forEach((candidate) => {
            let score = 0;
            const text = this.normalizeText(candidate.textContent || "");

            // Exact Text Match (Hash check is faster proxy for full string compare, but let's check hash first)
            if (this.hashCode(text) === descriptor.textHash) {
                score += 50;
            } else if (text.startsWith(descriptor.textSnippet)) {
                // Fuzzy Text Match (Snippet) - +30 score
                score += 30;
            }

            // Structural Match (Index)
            // We need to re-calculate index of this candidate to compare with descriptor.index
            // The descriptor.index is relative to the *found* parentId container.
            // So we must compare index within the scope we are searching.
            const siblings = Array.from(scope.querySelectorAll(descriptor.tag));
            const index = siblings.indexOf(candidate);
            if (index === descriptor.index) {
                score += 10;
            }

            if (score > highestScore) {
                highestScore = score;
                bestMatch = candidate;
            }
        });

        // 4. Winner
        if (highestScore > 30) {
            return bestMatch;
        }

        return null;
    }
}
